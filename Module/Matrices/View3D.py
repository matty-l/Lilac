"""
	This file contains a view transformation class for 3D projections.
	
	The view is defined by an internal camera an an external VTM. It is recommended
	that the VTM is generated using setView3D. It is recommended that the camera
	is edited at initialization or using config to avoid unexpected behavior, e.g.,
	safeguard against wrong key names.
	
	Author: Matthew Levine
	Date: 09/10/2015
"""
from Module.Matrices.Vector import ModuleVector as Vec
from Module.Matrices.Matrix import ViewTransformationMatrix as Mtx

class View3D:
	def __init__( self, **kwargs ):
		""" Creates a new View4D object. This is not usable without a view 
			transformation matrix generated by the method setView3D
		
			The possible arguments are:
				- vrp, Vector : the view reference point
				- vpn, Vector : the view plane normal 
				- vup, Vector : the up direction of the view
				- d,f,b, floats : clipping arguments
				- basis, float: directional definition (co-direction inferred)
				- cols, rows : image definition
				
		"""
		defaults = {
			'vrp' : Vec(3,2,-2), 'vpn' : Vec(-3,-2,2), 'vup' : Vec(0,1,0),
			'd' : 1., 'basis' : 2., 'f' : 0, 'b' : 4., 'rows' : 500,
			'cols' : 500
		}
		self._camera = { key : value if key not in kwargs else kwargs[key] \
									for key, value in defaults.items() }
		
	def config( self, *args, **kwargs ):
		""" Returns the values of the arguments given as a generator.
		
			Updates the camera based on the provided key word arguments. Raises
			an exception if the keyword arguments supplied are not valid camera
			parameters.
		"""
		def throw(key): raise Exception("Unknown camera argument \""+str(key)+'"')
		self._camera.update({key:val if key in self._camera else throw(key) for \
			key,val in kwargs.items() })
		return (self._camera[arg] for arg in args) if len(args) > 1\
			else self._camera[args[0]] if len(args) == 1 else self._camera.keys()
				
		
	def setView3D( self ):
		""" Sets the vtm to the given view transformation matrix """
		(vup,vpn,vrp,d,b,du,f,C,R) = \
			self.config('vup','vpn','vrp','d','b','basis','f','cols','rows')
		
		dv = du * R / C
		U = vup.cross(vpn)
		vup = vpn.cross(U) # vrc needs to be orthogonal
		vtm = Mtx()
		vtm.translate(-vrp[0],-vrp[1],-vrp[2])
		
		U.normalize()
		vup.normalize()
		vpn.normalize()
		vtm.rotateXYZ( U, vup,vpn )
		
		vtm.translate(0,0,d)
		
		# scale to cvv
		vrp = vtm.form_vector( vrp )
		b += d

		vtm.scale(2*d/(b*du),2*d/(b*dv),1/b)
		vtm.transform[3,2] /= b
		f = ( vrp[2] + f ) / b
				
		d /= b
		vtm.perspective( d )

		vtm.scale2D( -C/(2*d), -R/(2*d) )
		vtm.translate2D( C/2, R/2 )
		
		self._camera['vtm'] = vtm
		self.config(vup=vup,vrp=vrp,b=b,f=f,d=d)

		vtm.camera = self # tricksy cyclical hack, done with care
		return vtm